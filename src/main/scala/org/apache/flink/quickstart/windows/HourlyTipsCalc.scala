package org.apache.flink.quickstart.windows

import com.dataartisans.flinktraining.exercises.datastream_java.datatypes.TaxiFare
import com.dataartisans.flinktraining.exercises.datastream_java.sources.TaxiFareSource
import org.apache.flink.api.scala._
import org.apache.flink.streaming.api.TimeCharacteristic
import org.apache.flink.streaming.api.scala.function.ProcessWindowFunction
import org.apache.flink.streaming.api.scala.{DataStream, StreamExecutionEnvironment}
import org.apache.flink.streaming.api.windowing.time.Time
import org.apache.flink.streaming.api.windowing.windows.TimeWindow
import org.apache.flink.util.Collector

/**
  * Created by denis.shuvalov on 26/06/2018.
  *
  * The task of the “Hourly Tips” exercise is to identify, for each hour, the driver earning the most tips.
  * It’s easiest to approach this in two steps: first use hour-long windows that compute the total tips for each driver
  * during the hour, and then from that stream of window results, find the driver with the maximum tip total for each hour.
  *
  * Expected Output
  * The result of this exercise is a data stream of Tuple3[Long, Long, Float] records, one for each hour. Each hourly
  * record should contain the timestamp at the end of the hour, the driverId of the driver earning the most in tips
  * during that hour, and the actual total of their tips.
  */
object HourlyTipsCalc {
  def main(args: Array[String]): Unit = {

    val env = StreamExecutionEnvironment.getExecutionEnvironment
    env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)

    //Timestamps and watermarks can be either assigned and generated by a SourceFunction or using an explicit user-defined
    //timestamp assigner and watermark generator.
    val taxiFaresPath = "D:/Java/Learning/flinkscalaproject/src/main/resources/taxi/nycTaxiFares.gz"
    val fares: DataStream[TaxiFare] = env.addSource(new TaxiFareSource(taxiFaresPath, 1800))

    //Since elements are typically ingested in parallel, any operation that causes Flink to redistribute elements across
    //parallel stream partitions, such as parallelism changes, keyBy(), or other explicit redistributions, mixes up the
    //timestamp order of the elements.

    val hourlyTips = fares
      .keyBy(_.driverId)
      .timeWindow(Time.hours(1))
//      .timeWindow(Time.minutes(1))
      .process(new CalculateMaximumTotalTipPerDriver)

//      .print()


    hourlyTips
      .timeWindowAll(Time.hours(1))
      .maxBy(1)
      .map(tuple => s"""Driver id with most earnings is [${tuple._1}], earn total tips [${tuple._3}] within date [${tuple._2}]""")
      .print()

    env.execute("Calculate hourly tips per driver")
  }


}

class CalculateMaximumTotalTipPerDriver extends ProcessWindowFunction[TaxiFare, (Long, Long, Float), Long, TimeWindow] {

  def process(driverId: Long, context: Context, elements: Iterable[TaxiFare], out: Collector[(Long, Long, Float)]): Unit = {
    val totalTips = elements.map(_.tip).sum
    out.collect((driverId, context.window.getEnd, totalTips))
  }
}

//class FindDriverWithMostTipsEarning extends RichMapFunction[(Long, Long, Float), (Long, Long, Float)] {
//
//  private lazy val mostEarningDriver = getRuntimeContext.getState(
//    new ValueStateDescriptor[(Long, Long, Float)]("mostEarningDriver", classOf[(Long, Long, Float)])
//  )
//
//  def map(value: (Long, Long, Float)): (Long, Long, Float) = {
//    val driverWithMostEarnings = mostEarningDriver.value()
//  }
//}
